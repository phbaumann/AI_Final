

import java.util.LinkedList;
import java.util.concurrent.ThreadLocalRandom;

public class Algorithm_OLD {

	//this should always be divisible by 5
	private static final int GENSIZE = 48;
	private static final int PREFSIZE = GENSIZE/3;
	private static int PUZZNUM;
	static int mutRand = 0;

	public Algorithm_OLD(int puzz) {
		PUZZNUM = puzz;
	}

	public static int getGenSize() {
		return GENSIZE;
	}
	
	public static void setPuzz(int puzz){
		PUZZNUM = puzz;
	}

	// make a new population with only the members selected for crossover
	// choose top 50 of pop1 and top 50 of pop2 using merge sort
	public static Population_OLD parentSelection(Population_OLD pop1, Population_OLD pop2) {

		Member[] fits1 = new Member[GENSIZE];
		Member[] fits2 = new Member[GENSIZE];
		
		// add the tp 50 parents and top 50 children to the new pop
		Population_OLD newPop = new Population_OLD();
		for (int i = 0; i < GENSIZE; i++) {
			newPop.saveMember(pop1.getMember(i));
			newPop.saveMember(pop2.getMember(i));
		}
		

		return newPop;
	}

	// makes a new population with members generated by crossing over selected
	// parents
	public static Population_OLD makeBabies(Population_OLD pop) {
		Population_OLD newPop = new Population_OLD();

		Member mem1;
		Member mem2;
	

		for (int i = 0; i < GENSIZE; i++) {
			int rand = ThreadLocalRandom.current().nextInt(0, pop.getSize());
			int rand2 = ThreadLocalRandom.current().nextInt(0, pop.getSize());
			// use each member five times
			if(i < PREFSIZE){
				mem1 = pop.getMember(i);
			}
			else{
				mem1 = pop.getMember(rand);
			}

			
			// for each of the five times, choose random partner
			mem2 = pop.getMember(rand2);

			// make the babies! and add them to the new population
			Member newMem = null;
			// use a different crossover or each puzzle
			switch (PUZZNUM) {
			case 1:
				newMem = crossover1(mem1, mem2);
				break;
			case 2:
				newMem = crossover2(mem1, mem2);
				break;
			case 3:
				newMem = crossover3(mem1, mem2);
				break;
			default:
				System.out.println("You puzzle number is invalid");
				System.exit(0);
			}

			if (newMem != null) {
				newPop.saveMember(newMem);
			} else {
				System.out.println("crossover didn't create a new member");
				System.exit(0);
			}
		}

		return newPop;
	}

	// randomly combine genes of two members to make a new member
	private static Member crossover1(Member mem1, Member mem2) {

		Member newMem = mem1;

		int rand = ThreadLocalRandom.current().nextInt(0, mem1.getSize());

		// make baby from the pair of parents
		for (int i = 0; i <= rand; i++) {
			newMem.setGene(i, mem2.getGene(i));
		}
		// Generate a random number between 1 and 20
		// if 20, mutate current member
		mutRand = ThreadLocalRandom.current().nextInt(0, 21);
		if (mutRand == 20) {
			newMem = mutation1(newMem);
		}
		
		return newMem;
	}

	// randomly combine genes of two members to make a new member
	// corrects invalid babies
	private static Member crossover2(Member mem1, Member mem2) {

		Member newMem = mem1;

		int rand = ThreadLocalRandom.current().nextInt(1, mem1.getSize());
		// make baby from the pair of parents
		for (int i = 0; i < rand; i++) {
			newMem.setGene(i, mem2.getGene(i));
		}

		int len1 = 0;
		int len2 = 0;
		int len3 = 0;

		for (int i = 0; i < 30; i++) {
			switch (Integer.parseInt(newMem.getGene(i))) {
			case 1:
				len1++;
				break;
			case 2:
				len2++;
				break;
			case 3:
				len3++;
				break;
			default:
				System.out.println("got to the thing");
				break;
			}
		}

		while (len1 > 10 || len2 > 10 || len3 > 10) {

			for (int j = 0; j < 30; j++) {
				switch (Integer.parseInt(newMem.getGene(j))) {
					case 1:
						if(len1 > 10){
							if (len2 < 10) {
								newMem.setGene(j, "2");
								len2++;
							} else {
								newMem.setGene(j, "3");
								len3++;
							}
							len1--;
						}
						break;
					case 2:
						if(len2 > 10){
							if (len3 < 10) {
								newMem.setGene(j, "3");
								len3++;
							} else {
								newMem.setGene(j, "1");
								len1++;
							}
							len2--;
						}
						break;
					case 3:
						if(len3 > 10){
							if (len3 < 10) {
								newMem.setGene(j, "1");
								len1++;
							} else {
								newMem.setGene(j, "2");
								len2++;
							}
							len3--;
						}
						break;
					default:
						break;
				}
			}
		}
		// Generate a random number between 1 and 20
		// if 20, mutate current member
		mutRand = ThreadLocalRandom.current().nextInt(1, 21);
		if (mutRand == 20) {
			newMem = mutation2(newMem);
		}
		
		return newMem;
	}

	// randomly combine genes of two members to make a new member
	private static Member crossover3(Member mem1, Member mem2) {
		
		int c1 = 0;
		int c2 = 0;
		//count how many genes are in each member
		for(int i = 0; i < mem1.getSize();i++){
			if(Integer.parseInt(mem1.getGene(i))>0){
				c1++;
			}
			if(Integer.parseInt(mem2.getGene(i))>0){
				c2++;
			}
		}
		int[] inds1 = new int[c1];
		int[] inds2 = new int[c2];

		c1 = 0;
		c2=0;
		//grab all the indices for the true genes
		for (int i = 0; i < mem1.getSize(); i++) {
			if(Integer.parseInt(mem1.getGene(i))>0){
				inds1[c1] = i;
				c1++;
			}
			if(Integer.parseInt(mem2.getGene(i))>0){
				inds2[c2] = i;
				c2++;
			}
		}

		// sort the members of each list in ascending order
		for (int i = 0; i < inds1.length; i++) {
			int min1 = i;
			for (int j = i + 1; j < inds1.length; j++) {
				if (Integer.parseInt(mem1.getGene(inds1[j])) < Integer.parseInt(mem1.getGene(inds1[j]))){
					min1 = j;
				}
			}
			int temp = inds1[i];
			inds1[i] = inds1[min1];
			inds1[min1] = temp;
		}
		
		for (int i = 0; i < inds2.length; i++) {
			int min2 = i;
			for (int j = i + 1; j < inds2.length; j++) {
				if (Integer.parseInt(mem2.getGene(inds2[j])) < Integer.parseInt(mem2.getGene(inds2[j]))){
					min2 = j;
				}
			}
			int temp = inds2[i];
			inds2[i] = inds2[min2];
			inds2[min2] = temp;
		}

		int rand1 = ThreadLocalRandom.current().nextInt(0, inds1.length);
		int rand2 = ThreadLocalRandom.current().nextInt(0, inds2.length);
		
		int[] newInds = new int[rand1+(inds2.length-rand2)];
		
		//get the first section
		for(int i = 0; i < rand1;i++){
				newInds[i] = inds1[i];
		}
		//get the second section
		for(int i = 0; i< inds2.length-rand2;i++){
			newInds[rand1+i] = inds2[rand2+i];
		}
		
		//reconstruct the gene
		for(int i = 0; i < newInds.length;i++){
			for (int j = i+1; j < newInds.length;j++){
				if(newInds[i] == newInds[j]){
					newInds[j] = 0;
				}
			}
		}
		
		Member newMem = new MemberPuzz3(mem1.getVals(),false);
		for(int i = 0; i < newInds.length;i++){
			if(newInds[i] > 0){
				newMem.setGene(newInds[i], Integer.toString(i+1));
			}
		}
		// Generate a random number between 1 and 20
		// if 20, mutate current member
		mutRand = ThreadLocalRandom.current().nextInt(1, 21);
		if (mutRand == 20) {
			newMem = mutation3(newMem);
		}
				
		return newMem;
	}
	
	
	private static Member mutation1(Member mem) {
		Member mut = mem;
		
		return mut;
	}
	
	private static Member mutation3(Member mem) {
		Member mut = mem;
		
		return mut;
	}
	
	private static Member mutation2(Member mem) {
		Member mut = mem;
		
		return mut;
	}
	
	// add random genes into the population
	// TODO make this
	public Population_OLD mutate(Population_OLD pop) {
		return new Population_OLD();
	}
}
